package scrobbler

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/shkh/lastfm-go/lastfm"
	"go.uber.org/zap"

	"github.com/audirvana-origin-scrobbler/common"
	alog "github.com/audirvana-origin-scrobbler/log"
)

var (
	lastfmApi *lastfm.Api
)

type (
	Struct2Map interface {
		ToMap() (res map[string]interface{}, err error)
	}
	base struct {
		ApiKey string `json:"api_key"` // A Last.fm API key.
		ApiSig string `json:"api_sig"` //  A Last.fm method signature. See authentication for more information.
		Sk     string `json:"sk"`      //  A session key generated by authenticating a user via the authentication protocol.
	}

	PushTrackScrobbleReq struct {
		base
		Artist             string `json:"artist"`               // The artist name.
		AlbumArtist        string `json:"albumArtist,optional"` // The album artist - if this differs from the track artist.
		Track              string `json:"track"`                // The track name.
		Album              string `json:"album"`                // Sub-client version (not public, only enabled for certain API keys)
		TrackNumber        int64  `json:"trackNumber,optional"` // The track number of the track on the album.
		Timestamp          int64  `json:"timestamp"`            // The time the track started playing, in UNIX timestamp format (integer number of seconds since 00:00:00, January 1st 1970 UTC). This must be in the UTC time zone.
		MusicBrainzTrackID string `json:"mbid,optional"`        // The MusicBrainz Track ID.
		Context            string `json:"context,optional"`     // Sub-client version (not public, only enabled for certain API keys)
		StreamId           int64  `json:"streamId,optional"`    // The stream id for this track received from the radio.getPlaylist service, if scrobbling Last.fm radio
		Duration           int64  `json:"duration,optional"`    // The length of the track in seconds.
		ChosenByUser       int64  `json:"chosenByUser,optional"`
		Sk                 string `json:"sk"` // A session key generated by authenticating a user via the authentication protocol.
	}
	TrackUpdateNowPlayingReq struct {
		base
		Artist             string `json:"artist"`               // The artist name.
		AlbumArtist        string `json:"albumArtist,optional"` // The album artist - if this differs from the track artist.
		Track              string `json:"track"`                // The track name.
		Album              string `json:"album,optional"`       // Sub-client version (not public, only enabled for certain API keys)
		TrackNumber        int64  `json:"trackNumber,optional"` // The track number of the track on the album.
		MusicBrainzTrackID string `json:"mbid,optional"`        // The MusicBrainz Track ID.
		Context            string `json:"context,optional"`     // Sub-client version (not public, only enabled for certain API keys)
		Duration           int64  `json:"duration,optional"`    // The length of the track in seconds.

	}
	TrackUpdateNowPlayingResp struct {
		XMLName XMLName `json:"XMLName"`
		Track   struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Name"`
		} `json:"Track"`
		Artist struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Name"`
		} `json:"Artist"`
		Album struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Name"`
		} `json:"Album"`
		AlbumArtist struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Name"`
		} `json:"AlbumArtist"`
		IgnoredMessage struct {
			Corrected string `json:"Corrected"`
			Body      string `json:"Body"`
		} `json:"IgnoredMessage"`
	}
	GetLovedTracksResp struct {
		XMLName    XMLName `json:"XMLName"`
		User       string  `json:"User"`
		Total      int     `json:"Total"`
		Page       int     `json:"Page"`
		PerPage    int     `json:"PerPage"`
		TotalPages int     `json:"TotalPages"`
		Tracks     []Track `json:"Tracks"`
	}
	XMLName struct {
		Space string `json:"Space"`
		Local string `json:"Local"`
	}
	Date struct {
		Uts  string `json:"Uts"`
		Date string `json:"Date"`
	}
	Track struct {
		Name       string     `json:"Name"`
		Mbid       string     `json:"Mbid"`
		Url        string     `json:"Url"`
		Date       Date       `json:"Date"`
		Artist     Artist     `json:"Artist"`
		Images     []Images   `json:"Images"`
		Streamable Streamable `json:"Streamable"`
	}
	Artist struct {
		Name string `json:"Name"`
		Mbid string `json:"Mbid"`
		Url  string `json:"Url"`
	}
	Images struct {
		Size string `json:"Size"`
		Url  string `json:"Url"`
	}
	Streamable struct {
		FullTrack  string `json:"FullTrack"`
		Streamable string `json:"Streamable"`
	}
)

func init() {
}

func InitLastfmApi(apiKey, apiSecret, userLoginToken string, isMobile bool, userUsername, userPassword string) {
	lastfmApi = lastfm.New(apiKey, apiSecret)
	if isMobile {
		err := lastfmApi.Login(userUsername, userPassword)
		if err != nil {
			panic(err)
		}
	} else if len(userLoginToken) <= 0 {
		token, err := lastfmApi.GetToken()
		if err != nil {
			panic(err)
		}
		authUrl := lastfmApi.GetAuthTokenUrl(token)

		alog.Logger.Info(token)
		ok := promptUser(authUrl)
		if ok {
			err = lastfmApi.LoginWithToken(token)
			if err != nil {
				panic(err)
			}
		} else {
			panic("登陆失败")
		}
	} else {
		err := lastfmApi.LoginWithToken(userLoginToken)
		if err != nil {
			panic(err)
		}
	}
}
func promptUser(url string) bool {
	fmt.Println("请在浏览器中打开以下URL，并完成验证码验证:")
	fmt.Println(url)
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("验证完成请输入【ok】完成验证，键入回车: ")
	text, _ := reader.ReadString('\n')
	text = removeNewlines(text)
	return strings.TrimSpace(text) == "ok"
}

func removeNewlines(s string) string {
	return strings.ReplaceAll(s, "\n", "")
}

func (t *PushTrackScrobbleReq) ToMap() (res map[string]interface{}, err error) {
	res = make(map[string]any)
	err = common.Decode(t, &res)
	if err != nil {
		return nil, err
	}
	return
}

func (t *TrackUpdateNowPlayingReq) ToMap() (res map[string]interface{}, err error) {
	res = make(map[string]any)
	err = common.Decode(t, &res)
	if err != nil {

		return nil, err
	}
	return
}

/*
1.数据源服务：

	定时copy audirvana sqllite数据库 备份到mysql

2.采集上报lastfm服务：

	从mysql中取出最近播放列表
	检查是否标记LOVE
	检查是否标记跳过
	检查播放时长是否大于50%
	上报数据

3.采集用户lastfm top数据

	top album
	top track
	top artist
*/

func GetLovedTracksUser(user string, limit int) (result *GetLovedTracksResp, err error) {
	resp, err := lastfmApi.User.GetLovedTracks(
		map[string]interface{}{
			"user":  "vincentch1n",
			"limit": "10",
		},
	)
	if err != nil {
		return nil, err
	}
	marshal, err := json.Marshal(resp)
	if err != nil {
		return nil, err
	}
	result = new(GetLovedTracksResp)
	err = json.Unmarshal(marshal, result)
	if err != nil {
		return nil, err
	}
	return
}

func PushTrackScrobble(req *PushTrackScrobbleReq) (string, error) {
	alog.Logger.Info("PushTrackScrobble:", zap.Any("req", req))
	reqMap, err := req.ToMap()
	if err != nil {
		alog.Logger.Warn("TrackUpdateNowPlaying", zap.Error(err))
		return "", err
	}
	result, err := lastfmApi.Track.Scrobble(reqMap)
	if err != nil {
		alog.Logger.Warn("TrackUpdateNowPlaying", zap.Error(err))
		return "", err
	}

	marshal, err := json.Marshal(result)
	if err != nil {
		alog.Logger.Warn("TrackUpdateNowPlaying", zap.Error(err))
		return "", err
	}
	return string(marshal), nil
}

func TrackUpdateNowPlaying(req *TrackUpdateNowPlayingReq) error {
	alog.Logger.Info("TrackUpdateNowPlaying", zap.Any("req", req))
	resp := new(TrackUpdateNowPlayingResp)
	argsMap, err := req.ToMap()
	if err != nil {
		return err
	}
	result, err := lastfmApi.Track.UpdateNowPlaying(argsMap)
	if err != nil {
		alog.Logger.Warn("TrackUpdateNowPlaying", zap.Error(err))
		return err
	}

	marshal, err := json.Marshal(result)
	if err != nil {
		alog.Logger.Warn("TrackUpdateNowPlaying", zap.Error(err))
		return err
	}
	err = json.Unmarshal(marshal, resp)
	if err != nil {
		alog.Logger.Warn("TrackUpdateNowPlaying", zap.Error(err))
		return err
	}

	// alog.Logger.Info(resp)
	return nil
}
